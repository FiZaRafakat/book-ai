# API Contracts: ROS 2 Robotics Module

## Overview
This document outlines the ROS 2 interfaces and function signatures that will be taught in the documentation module. These represent the educational contracts that students will learn to implement.

## Chapter 1: ROS 2 Communication Fundamentals

### Basic Node Interface
```python
import rclpy
from rclpy.node import Node

class BasicNode(Node):
    def __init__(self, node_name: str):
        """
        Initialize a basic ROS 2 node
        Args:
            node_name: Unique name for the node
        """
        super().__init__(node_name)
```

### Node Lifecycle Methods
```python
def create_node(self, node_name: str) -> Node:
    """
    Creates a new ROS 2 node instance
    Returns:
        Node: Initialized node object
    """

def destroy_node(self) -> None:
    """
    Cleans up and destroys the node
    """
```

## Chapter 2: Python Control with rclpy

### Publisher Interface
```python
def create_publisher(self, msg_type, topic_name: str, qos_profile) -> Publisher:
    """
    Creates a publisher for sending messages
    Args:
        msg_type: Type of message to publish
        topic_name: Name of the topic to publish to
        qos_profile: Quality of Service settings
    Returns:
        Publisher: Publisher object for sending messages
    """

def publish(self, msg) -> None:
    """
    Publishes a message to the topic
    Args:
        msg: Message to publish
    """
```

### Subscriber Interface
```python
def create_subscription(self, msg_type, topic_name: str, callback, qos_profile) -> Subscription:
    """
    Creates a subscription for receiving messages
    Args:
        msg_type: Type of message to subscribe to
        topic_name: Name of the topic to subscribe to
        callback: Function to call when message received
        qos_profile: Quality of Service settings
    Returns:
        Subscription: Subscription object for receiving messages
    """
```

### Service Client Interface
```python
def create_client(self, srv_type, srv_name: str, qos_profile=None) -> Client:
    """
    Creates a service client
    Args:
        srv_type: Type of service
        srv_name: Name of the service
        qos_profile: Quality of Service settings
    Returns:
        Client: Service client object
    """

def call_async(self, request) -> Future:
    """
    Makes an asynchronous service call
    Args:
        request: Request message to send
    Returns:
        Future: Future object for the response
    """
```

### Service Server Interface
```python
def create_service(self, srv_type, srv_name: str, callback, qos_profile=None) -> Service:
    """
    Creates a service server
    Args:
        srv_type: Type of service
        srv_name: Name of the service
        callback: Function to call when request received
        qos_profile: Quality of Service settings
    Returns:
        Service: Service server object
    """
```

## Chapter 3: Humanoid Structure with URDF

### URDF Parsing Interface
```python
def load_urdf_from_file(self, file_path: str) -> RobotDescription:
    """
    Loads a URDF model from a file
    Args:
        file_path: Path to the URDF file
    Returns:
        RobotDescription: Parsed robot model
    """

def load_urdf_from_string(self, urdf_string: str) -> RobotDescription:
    """
    Loads a URDF model from a string
    Args:
        urdf_string: URDF content as string
    Returns:
        RobotDescription: Parsed robot model
    """
```

### Robot Model Interface
```python
def get_links(self) -> List[Link]:
    """
    Gets all links in the robot model
    Returns:
        List[Link]: List of all links
    """

def get_joints(self) -> List[Joint]:
    """
    Gets all joints in the robot model
    Returns:
        List[Joint]: List of all joints
    """

def get_root_link(self) -> Link:
    """
    Gets the root link of the robot
    Returns:
        Link: Root link of the robot
    """

def get_joint_chain(self, start_link: str, end_link: str) -> List[Joint]:
    """
    Gets the chain of joints between two links
    Args:
        start_link: Starting link name
        end_link: Ending link name
    Returns:
        List[Joint]: List of joints in the chain
    """
```

### Link Interface
```python
class Link:
    def __init__(self, name: str):
        self.name = name
        self.visual = None
        self.collision = None
        self.inertial = None

    def get_visual_geometry(self):
        """
        Gets the visual geometry of the link
        """

    def get_collision_geometry(self):
        """
        Gets the collision geometry of the link
        """

    def get_inertial_properties(self):
        """
        Gets the inertial properties of the link
        """
```

### Joint Interface
```python
class Joint:
    def __init__(self, name: str, joint_type: str, parent_link: str, child_link: str):
        self.name = name
        self.type = joint_type  # 'revolute', 'continuous', 'prismatic', 'fixed', etc.
        self.parent = parent_link
        self.child = child_link
        self.axis = None
        self.limits = None

    def get_joint_type(self) -> str:
        """
        Returns the type of joint
        """

    def get_parent_link(self) -> str:
        """
        Returns the parent link name
        """

    def get_child_link(self) -> str:
        """
        Returns the child link name
        """

    def get_limits(self) -> JointLimits:
        """
        Returns the joint limits
        """
```

## Common Message Types for Examples

### Standard Message Types
- std_msgs.msg.String
- std_msgs.msg.Int32
- std_msgs.msg.Float32
- geometry_msgs.msg.Twist
- sensor_msgs.msg.JointState

### Service Types
- std_srvs.srv.Empty
- std_srvs.srv.SetBool
- std_srvs.srv.Trigger

## Expected Behavior Contracts

### Node Communication Contract
- Publishers must publish messages of the correct type to topics
- Subscribers must handle messages of the expected type
- Services must respond to requests within a reasonable timeframe
- Nodes must handle lifecycle events properly

### Error Handling Contract
- All ROS 2 operations must include appropriate error handling
- Nodes must gracefully handle connection/disconnection events
- Message validation must occur before processing
- Resource cleanup must happen during node destruction

### Performance Contract
- Message publishing should not block the main thread
- Service responses should be timely (under 1 second for simple operations)
- Node initialization should complete within reasonable time
- Memory usage should be stable during normal operation